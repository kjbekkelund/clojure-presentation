<!DOCTYPE html>
<html>
  <head>
    <title>Clojure-intro</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href='http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:400,700,200' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
    <script src="https://raw.github.com/gnab/remark/master/remark.min.js" type="text/javascript">
      { "highlightStyle": "monokai", "highlightLanguage": "clojure", "highlightInline": true }
    </script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine();
    </script>
    <script src="clojure.js" type="text/javascript"></script>
    <style type="text/css" media="screen">
      .frontpage {
        background: url(images/clojure-icon.gif) no-repeat 50% 35%;
      }
      .blur {
        background: url(images/clojure-blur.png) no-repeat bottom right;
      }
      h1, h2 {
        font-family: 'Yanone Kaffeesatz';
        font-size: 3em;
        font-weight: 400;
      }
      .tilstand h1 {
        margin-bottom: 0em;
      }
      h2 {
        font-size: 2em;
        margin: 0;
        margin-bottom: 10px;
      }
      pre code {
        -moz-border-radius: 15px;
        -web-border-radius: 15px;
        border-radius: 15px;
        padding: 15px 20px;
      }
      .clojure .title {
        color: #F92672;
        font-weight: bold;
      }
      #slideshow .slide .content code { font-family: 'Inconsololata', monospace; }
      .red {
        color: #F92672;
      }
      .left-col {
        float: left;
        width: 47%;
      }
      .right-col {
        float: right;
        width: 47%;
      }
      .left-col-40 {
        float: left;
        width: 37%;
      }
      .right-col-60 {
        float: right;
        width: 57%;
      }
      .footnote {
        position: absolute;
        bottom: 3.5em;
      }
      .adjust {
        padding-bottom: 31px;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

.frontpage.center.middle
# (clojure-intro)

---

.blur

# Agenda

##Clojure, LISP og JVMen
##Innebygde datastrukturer
##Sekvenser
##Funksjoner
##Tilstand
##Makroer

##Spørsmål?

---

# Clojure er en LISP.red[*]-dialekt

Prefiks-notasjon i stedet for infiks-notasjon:

    + 1 * 2 3

Datastrukturer som kode i stedet for tekst:

    (+ 1 (* 2 3)) ; => 1 + 2 * 3 = 1 + 6 = 7

Uvanlig fleksibelt makrosystem - kode behandler kode som datastrukturer:

    (xml                        ; => <xml>
      (book                     ;      <book>
        (authors                ;        <authors>
          (author "Luke")       ;          <author>Luke</author>
          (author "Stuart"))))  ;          ...

.footnote[.red[*] LISt Processing]

---

# Clojure er implementert på JVMen.red[*]

Om man "oversetter" direkte fra Java kan man like gjerne bruke Java:

    (def numbers (new java.util.ArrayList)) ; => #<ArrayList []>
    (. numbers add 1)
    (. numbers add 2)
    (. numbers add 3)
    ; numbers => #<ArrayList [1, 2, 3]>

Men bruk av idiomatisk Clojure kan gi det beste fra begge verdener:

    (map (memfn toUpperCase) ["a" "short" "message"])
    ; => ("A" "SHORT" "MESSAGE")

.footnote[.red[*] En sekundær implementasjon finnes også til CLRen.]

---

# Innebygde datastrukturer (1/2)

`nil` - representert ved `null`:

    (if nil "nil is true" "nil is false") ; => "nil is false"

Tall - støtter alle JVM-primitiver, samt mer eksotiske konstruksjoner:

    (/ 22 7) ; => 22/7

Strenger og tegn - representert ved `String` og `char`:

    (str "Hello" " world!") ; => "Hello world!"

Nøkkelord - evaluerer til seg selv og brukes som nøkler, à la symboler i Ruby:

    (:a {:a 1 :b 2}) ; => 1

---

# Innebygde datastrukturer (2/2)  

.left-col[
Lister:
  
    (list 1 2 3) ; => (1 2 3)
    '(1 2 3)     ; => (1 2 3)
]
.right-col[
Vektorer:
  
    (vec 1 2 3) ; => [1 2 3]
    [1 2 3]     ; => [1 2 3]
]

<div style="clear: both"></div>

Maps:

    (hash-map :a 1 :b 2) ; => {:a 1, :b 2}
    {:a 1 :b 2}          ; => {:a 1, :b 2}

Sett:

    (hash-set 1 2 3) ; => #{1 2 3}
    #{1 2 3}         ; => #{1 2 3}

---

# Sekvenser

Felles grensesnitt implementert av **lister**, **vektorer**, **maps**, **sett** m.fl.:

    (first [1 2 3]) ; => 1
    (rest  [1 2 3]) ; => (2 3)
    (cons  1 [2 3]) ; => (1 2 3)

Basis for bibliotek av funksjoner for sekvenser, slik som:

    (second [1 2 3])     ; => 2
    (nth [1 2 3] 2)      ; => 3

    (last [1 2 3])       ; => 3
    (concat [1 2] [3 4]) ; => (1 2 3 4)

    (map ...)
    (filter ...)
    (take ...)
    (partition ...)

---

# Funksjoner

Kall er lister med funksjon etterfulgt av argumenter:

    (func  arg1 arg2 arg3)
    (apply func arg1 [arg2 arg3]) ; => (func arg1 arg2 arg3)

Definisjon utføres av `fn`, evt. indirekte vha. andre funksjoner/makroer:

    (fn [a b] (+ a b))

    #(+ 2 %) ; => (fn [%] (+ 2 %))

    (defn addTwo [a b] 
      (+ a b))

    (defn addMany [& args] 
      (apply + args))

---

# Eksempel

Klumpete Java-metode for å returnere kopi av liste med hvert element doblet:

    .java
    int[] doubleElements (int[] someArray) {
      int[] newArray = new int[someArray.length];

      for (int i = 0; i < someArray.length; i++) {
        newArray[i] = someArray[i] * 2;
      }

      return newArray;
    }

Elegant løsning vha. sekvensfunksjoner:

    (defn doubleElements [list]
      (map #(* 2 %)) list)

    (doubleElements [0 1 2 3])  ; => (0 2 4 6)

---
.tilstand

# Tilstand

.left-col[
## Vars
Tilstand lokal for tråd, omtrent som globale variabler:

    (def x 1)
    (def x (+ 1 x))
]
.right-col[
## Refs
Tilstand oppdatert synkront i transaksjoner, f. eks. kontosaldo:

    (def x (ref 0))
    (dosync (alter x + 1)) ; => 1
]
<div style="clear: left"></div>
.left-col[
## Agents
Tilstand oppdatert asynkront, f. eks. i.f.m. logging:

    (def x (agent 0))
    (send x + 1) ; => #<Agent@..: 1>
]
.right-col[
## Atoms
Tilstand oppdatert synkront, ikke i transaksjoner:

    (def x (atom 0))
    (swap! x + 1) ; => 1
]

---

# Makroer

.left-col-40[
Evaluering av funksjoner:

    (+ (+ 2 3) (* 4 5)) 

&nbsp;&nbsp;&nbsp;&nbsp;1\. `(+ 2 3)`


    (+ 5 (* 4 5))

&nbsp;&nbsp;&nbsp;&nbsp;2\. `(* 4 5)`
 
    (+ 5 20) 

&nbsp;&nbsp;&nbsp;&nbsp;3\. `(+ 5 20)`

    (+ 5 20) ; => 25
]

.right-col-60[
Evaluering av makroer:

    (xml (book (author "Luke")))

&nbsp;&nbsp;&nbsp;&nbsp;1\. Makro ekspanderes og ny kode returneres:

    .adjust
    (defn xml-helper [form]
      (if (not (seq? form))
        (str form)
        (let [name (first form)
              children (rest form)]
          (str "<" name ">"
               (apply str 
                 (map xml-helper children))
               "</" name ">"))))

    (defmacro xml [form]
      (xml-helper form))

]

---

.middle.blur
# Spørsmål?

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
