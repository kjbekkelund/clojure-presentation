<!DOCTYPE html>
<html>
  <head>
    <title>Clojure-intro</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href='http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:400,700,200' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
    <script src="https://raw.github.com/gnab/remark/master/remark.min.js" type="text/javascript">
      { "highlightStyle": "monokai", "highlightLanguage": "lisp" }
    </script>
    <style type="text/css" media="screen">
      .frontpage {
        background: url(images/clojure-icon.gif) no-repeat 50% 35%;
      }
      h1 {
        font-family: 'Yanone Kaffeesatz';
        font-size: 3em;
        font-weight: 400;
      }
      pre code {
        -moz-border-radius: 15px;
        -web-border-radius: 15px;
        border-radius: 15px;
        padding: 15px 20px;
      }
      #slideshow .slide .content code { font-family: 'Inconsololata', monospace; }
      .red {
        color: #F92672;
      }
      .footnote {
        position: absolute;
        bottom: 3.5em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

.frontpage.center.middle
# (clojure-intro)

---

# Agenda

1. Clojure og Lisp
2. Innebygde datastrukturer
3. Collections og sequences
5. Tilstand
6. Java interop

---

# Clojure er en LISP.red[*]

* Prefiks-notasjon i stedet for infiks-notasjon:

      + 1 * 2 3

* Datastrukturer som kode i stedet for tekst:

      (+ 1 (* 2 3)) ; => 1 + 2 * 3 = 1 + 6 = 7

* Uvanlig fleksibelt makrosystem - kode som selv produserer nye strukturer:

      (defmacro infix [left operator right]
        (list operator left right))

      (infix 1 + 2) ; => (+ 1 2)

.footnote[.red[*] LISt Processing]

---

# Clojure er implementert på JVMen.red[*]

* Om man "oversetter" direkte fra Java kan man like gjerne bruke Java:

      (def liste (new java.util.ArrayList)) ; => #<ArrayList []>
      (. liste add 1)
      (. liste add 2)
      (. liste add 3)
      ; liste => #<ArrayList [1, 2, 3]>

* Men bruk av idiomatisk Clojure kan gi det beste fra begge verdener:

      (map (memfn toUpperCase) ["a" "short" "message"])
      ; => ("A" "SHORT" "MESSAGE")

.footnote[.red[*] En sekundær implementasjon finnes også til CLRen.]

---

# Innebygde datastrukturer

nil 

    (if nil "nil evaluates to true" "nil evaluates to false")

Tall: Full støtte for JVM-primitivene

    (/ 22 7) gir 22/7

Strings og Characters samme som Java sine Strings og Characters

    (str "Hello" " world!")

Keywords:

    (:a {:a 1 :b 2}) ; 1

---

# Lists

    (= '(1 2 3) (list 1 2 3))  ;true
      
    (peek '(1 2 3)) ; 1 

    (pop '(1 2 3)) ; (2 3)

    (list? '(1 2 3)) ; true


---

# Vectors

    (= [1 2 3] (vector 1 2 3)) ; true

    (get [1 2 3] 0) ; 1

    (nth [1 2 3] 0) ; 1

    (peek [1 2 3])  ; 3

    (pop [1 2 3])  ; [1 2]

    (vector? [1 2 3]) ; true

---

# Maps

    (= {:a 1 :b 1} (hash-map :a 1 :b 1)) ; true

    (get {:a 1 :b 1} :a) ; 1

    ({:a 1 :b 1} :a) ; 1

    (:a {:a 1 :b 1}) ; 1

    (contains? {:a 1 :b 1} :a) ; true

    (map? {:a 1 :b 1}) ; true

---


# Sets

    (= #{1 2 3} (hash-set 1 2 3)) ; true

    (get #{1 2 3} 1) ; 1

    (contains? #{1 2 3} 1) ; true
    
    (set? #{1 2 3}) ; true

---

# Seq-grensesnittet, motivasjon


    .java
    // eks: [0 1 2 3] blir til [0 2 4 6]
    void double(int[] someArray) {
      int[] newArray = new int[someArray.length];
      for (int i = 0; i < someArray.length; i++){
        newArray[i] = someArray[i] * 2;
      }
      return newArray;
    }

---


#Seq-grensesnittet, forts.

Nyttig abstraksjon for å gjøre liknende operasjoner finner vi i map:

    (map (fn[a] (* 2 a)) [0 1 2 3]) ; (0 2 4 6)

Fungerer også for andre datastrukturerer:

    (map (fn[a] (* 2 a)) '(0 1 2 3)) ; (0 2 4 6)

map-funksjonen støtter alle datastrukturer som implementerer Seq-grensesnittet, noe både vektorer og lister gjør!

---
#Seq-grensesnittet, forts.

Seq er et grensesnitt som gjør at den underliggende implementasjonen kan ses på som en logisk liste. 

Gir mulighet for datastrukturer med mange tilhørende operasjoner.

---

# Tilstand

Funksjonell programmering er bra, men hva med lagring av tilstand?

* Vars
* Refs
* Agents
* Atoms

Disse forskjellige typene forsøker å løse samtidigsproblemer man ofte møter på ved tilstandsoppdateringer.

---

# Vars

* Mekanisme for å referere til en minnelokasjon. Referansen kan bindes på nytt. 


    .lisp
    (def a 1) ; 'lager' en Var og gir en initiell verdi, a = 1
    (def a (+ 1 a)) ; a = 2

Kan ses på som en global variabel, men bruk av binding-form gir mulighet å tråd-lokale verdier:

    .lisp
    (def ^:dynamic x 1)
    (binding [x 2] (println x)) ; 2
    (println x)                 ; 1    

---

# Refs

Brukes for tilstandsoppdatering som må være synkronisert med transaksjonshåndtering mellom tråder.

Eksempel på bruk: Sette inn penger på konto

---

# Agents

Brukes for tilstandsoppdatering hvor det ikke er viktig når selve oppdateringen skjer.

    .lisp
    (def x (agent)) 
    (send x + 1) ; #<Agent@2db6235b: 1>

Eksempel på bruk: Skrive til logg

---

# Atoms

Brukes for synkron tilstandsoppdatering som ikke skal være delt med andre

    .lisp
    (def x (atom 0))
    (swap! x + 1) ; 1

Eksempel på bruk: Memoisering

---

# Makroer, motivasjon

I Clojure evaluares lister som funksjonskall:

    (+ 1 (+ 2 3) (* 4 5)) 
    (+ 1 5 (* 4 5) ; 2. argument evaluert
    (+ 1 5 20) ; 3. argument evaluert
    26         ; evaluering av funksjon med argumenter

If-metoden omgår denne regelen:
    
    (def counter (atom 0))
    (if (= 1 1) 
      (swap! counter inc)
      (swap! counter inc)) ; 1
   
Slike unntak fra standard-evaluering gjøres med makroer!

---

.center.middle
# Spørsmål?

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
