<!DOCTYPE html>
<html>
  <head>
    <title>Clojure-intro</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href='http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:400,700,200' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
    <script src="https://raw.github.com/gnab/remark/master/remark.min.js" type="text/javascript">
      { "highlightStyle": "monokai", "highlightLanguage": "clojure" }
    </script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine();
    </script>
    <script src="clojure.js" type="text/javascript"></script>
    <style type="text/css" media="screen">
      .frontpage {
        background: url(images/clojure-icon.gif) no-repeat 50% 35%;
      }
      h1 {
        font-family: 'Yanone Kaffeesatz';
        font-size: 3em;
        font-weight: 400;
      }
      pre code {
        -moz-border-radius: 15px;
        -web-border-radius: 15px;
        border-radius: 15px;
        padding: 15px 20px;
      }
      pre .clojure .title {
        color: #F92672;
      }
      #slideshow .slide .content code { font-family: 'Inconsololata', monospace; }
      .red {
        color: #F92672;
      }
      .headnote {
        font-family: 'Yanone Kaffeesatz';
        font-size: 1.5em;
        position: absolute;
        top: 1em;
      }
      .footnote {
        position: absolute;
        bottom: 3.5em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

.frontpage.center.middle
# (clojure-intro)

---

# Agenda

1. Clojure og Lisp
2. Innebygde datastrukturer
3. Collections og sequences
5. Tilstand
6. Java interop

---

# Clojure er en LISP.red[*]

* Prefiks-notasjon i stedet for infiks-notasjon:

      + 1 * 2 3

* Datastrukturer som kode i stedet for tekst:

      (+ 1 (* 2 3)) ; => 1 + 2 * 3 = 1 + 6 = 7

* Uvanlig fleksibelt makrosystem - kode som selv produserer nye strukturer:

      (defmacro infix [left operator right]
        (list operator left right))

      (infix 1 + 2) ; => (+ 1 2) => 1 + 2 = 3

.footnote[.red[*] LISt Processing]

---

# Clojure er implementert på JVMen.red[*]

* Om man "oversetter" direkte fra Java kan man like gjerne bruke Java:

      (def liste (new java.util.ArrayList)) ; => #<ArrayList []>
      (. liste add 1)
      (. liste add 2)
      (. liste add 3)
      ; liste => #<ArrayList [1, 2, 3]>

* Men bruk av idiomatisk Clojure kan gi det beste fra begge verdener:

      (map (memfn toUpperCase) ["a" "short" "message"])
      ; => ("A" "SHORT" "MESSAGE")

.footnote[.red[*] En sekundær implementasjon finnes også til CLRen.]

---

# Innebygde datastrukturer (1/3)

* `nil` - representert ved `null`:

      (if nil "nil is true" "nil is false") ; => "nil is false"

* Tall - støtter alle JVM-primitiver, samt mer eksotiske konstruksjoner:

      (/ 22 7) ; => 22/7

* Strenger og tegn - representert ved `String` og `char`:

      (str "Hello" " world!") ; => "Hello world!"

* Nøkkelord - evaluerer til seg selv og brukes som nøkler, à la symboler i Ruby:

      (:a {:a 1 :b 2}) ; => 1

---

# Innebygde datastrukturer (2/3)

* Lister:

      (list 1 2 3) ; => (1 2 3)
      '(1 2 3)     ; => (1 2 3)

* Vektorer:

      (vec 1 2 3) ; => (1 2 3)
      '(1 2 3)     ; => (1 2 3)

* Sett:

      (hash-set 1 2 3) ; => (1 2 3)
      #{1 2 3}         ; => (1 2 3)

---

# Innebygde datastrukturer (3/3)

* Maps:

      (hash-map :a 1 :b 2)   ;=> {:a 1, :b 2}
      (sorted-map :b 2 :a 2) ;=> {:a 1, :b 2}

---

# Maps

    (= {:a 1 :b 1} (hash-map :a 1 :b 1)) ; true

    (get {:a 1 :b 1} :a) ; 1

    ({:a 1 :b 1} :a) ; 1

    (:a {:a 1 :b 1}) ; 1

    (contains? {:a 1 :b 1} :a) ; true

    (map? {:a 1 :b 1}) ; true

---


# Sets

    (= #{1 2 3} (hash-set 1 2 3)) ; true

    (get #{1 2 3} 1) ; 1

    (contains? #{1 2 3} 1) ; true
    
    (set? #{1 2 3}) ; true

---

# Seq-grensesnittet


    .java
    // eks: [0 1 2 3] blir til [0 2 4 6]
    void double(int[] someArray) {
      int[] newArray = new int[someArray.length];
      for (int i = 0; i < someArray.length; i++){
        newArray[i] = someArray[i] * 2;
      }
      return newArray;
    }

---


#Seq-grensesnittet, forts.

Nyttig abstraksjon for å gjøre liknende operasjoner finner vi i map:

    (map (fn[a] (* 2 a)) [0 1 2 3]) ; (0 2 4 6)

Fungerer også for andre datastrukturerer:

    (map (fn[a] (* 2 a)) '(0 1 2 3)) ; (0 2 4 6)

map-funksjonen støtter alle datastrukturer som implementerer Seq-grensesnittet, noe både vektorer og lister gjør!

---
#Seq-grensesnittet, forts.

Seq er et grensesnitt som gjør at den underliggende implementasjonen kan ses på som en logisk liste. 

Gir mulighet for datastrukturer med mange tilhørende operasjoner.

---

# Tilstand

Funksjonell programmering er bra, men hva med lagring av tilstand?

* Vars
* Refs
* Agents
* Atoms

---

# Vars

* Mekanisme for å referere til en minnelokasjon. Referansen kan bindes på nytt. 


    .lisp
    (def a 1) ; 'lager' en Var og gir en initiell verdi, a = 1
    (def a (+ 1 a)) ; a = 2

Kan ses på som en global variabel, men bruk av binding-form gir mulighet å tråd-lokale verdier:

    .lisp
    (def ^:dynamic x 1)
    (binding [x 2] (println x)) ; 2
    (println x)                 ; 1    

---

# Refs

Brukes for tilstandsoppdatering som må være synkronisert med transaksjonshåndtering mellom tråder.

Eksempel på bruk: Sette inn penger på konto

---

# Agents

Brukes for tilstandsoppdatering hvor det ikke er viktig når selve oppdateringen skjer.

    .lisp
    (def x (agent)) 
    (send x + 1) ; #<Agent@2db6235b: 1>

Eksempel på bruk: Skrive til logg

---

# Atoms

Brukes for synkron tilstandsoppdatering som ikke skal være delt med andre

    .lisp
    (def x (atom 0))
    (swap! x + 1) ; 1

Eksempel på bruk: Memoisering

---

# Makroer, motivasjon

Standard evaluering av lister i Clojure:

    (+ (+ 2 3) (* 4 5)) 

1. Evaluer (+ 2 3)


    (+ 5 (* 4 5))

2. Evaluer (* 4 5)

 
    (+ 5 20) 

3. Evaluer + med 5 og 20 som argumenter


    (+ 5 20) ; 25

---

# Makroer, forts.

If-metoden omgår denne regelen:
    
    (def counter (atom 0))
    (if (= 1 1) 
      (swap! counter inc)
      (swap! counter inc)) 
    ; 1
   
Slike unntak fra standard-evaluering gjøres med makroer!

    (defmacro when [test body]
      (list 'if test body))

---


.center.middle
# Spørsmål?

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
