<!DOCTYPE html>
<html>
  <head>
    <title>Clojure-intro</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href='http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:400,700,200' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
    <script src="https://raw.github.com/gnab/remark/master/remark.min.js" type="text/javascript">
      { "highlightStyle": "monokai", "highlightLanguage": "lisp" }
    </script>
    <style type="text/css" media="screen">
      .frontpage {
        background: url(images/clojure-icon.gif) no-repeat 50% 35%;
      }
      h1 {
        font-family: 'Yanone Kaffeesatz';
        font-size: 3em;
        font-weight: 400;
      }
      pre code {
        -moz-border-radius: 15px;
        -web-border-radius: 15px;
        border-radius: 15px;
        padding: 15px 20px;
      }
      #slideshow .slide .content code { font-family: 'Inconsololata', monospace; }
      .red {
        color: #F92672;
      }
      .footnote {
        position: absolute;
        bottom: 3.5em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

.frontpage.center.middle
# (clojure-intro)

---

# Agenda

1. Clojure og Lisp
2. Innebygde datastrukturer
3. Collections og sequences
5. Tilstand
6. Java interop

---

# Clojure er en LISP.red[*]

* Prefiks-notasjon i stedet for infiks-notasjon:

      + 1 * 2 3

* Datastrukturer som kode i stedet for tekst:

      (+ 1 (* 2 3)) ; => 1 + 2 * 3 = 1 + 6 = 7

* Uvanlig fleksibelt makrosystem - kode som selv produserer nye strukturer:

      (defmacro infix [left operator right]
        (list operator left right))

      (infix 1 + 2) ; => (+ 1 2)

.footnote[.red[*] LISt Processing]

---

# Clojure er implementert på JVMen.red[*]

* Om man "oversetter" direkte fra Java kan man like gjerne bruke Java:

      (def liste (new java.util.ArrayList)) ; => #<ArrayList []>
      (. liste add 1)
      (. liste add 2)
      (. liste add 3)
      ; liste => #<ArrayList [1, 2, 3]>

* Men bruke av idiomatisk Clojure kan gi det beste fra begge verdener:

      (map (memfn toUpperCase) ["a" "short" "message"])
      ; => ("A" "SHORT" "MESSAGE")

.footnote[.red[*] En sekundær implementasjon finnes også til CLRen.]

---

# Innebygde datastrukturer

* nil : Mulig verdi for enhver datatype i Clojure. Alt annet enn nil og false er logisk sant.
* Tall: Full støtte for JVM-primitivene
* Ratio: (/ 22 7) gir 22/7
* Strings og Characters: Clojure strings og characters er lik Java strings og Characters
* Keywords: Evaluerer til seg selv. SKrives med kolon,f.eks :someKeyword
* Symboler: Referanser til funksjonsparametre, bindinger, klassenavn og globale variabler.
* Collections: Lists, Vectors, Maps, Sets

---

# Lists

    (= '(1 2 3) (list 1 2 3))  ;true
      
    (peek '(1 2 3)) ; 1 

    (pop '(1 2 3)) ; (2 3)

    (list? '(1 2 3)) ; true


---

# Vectors

Vectors i Clojure er collections som er indeksert av sammenhengende (contiguous heltall.

    (= [1 2 3] (vector 1 2 3)) ; true

    (get [1 2 3] 0) ; 1

    (nth [1 2 3] 0) ; 1

    (peek [1 2 3])  ; 3

    (pop [1 2 3])  ; [1 2]

    (vector? [1 2 3]) ; true

---

# Maps

    (= {:a 1 :b 1} (hash-map :a 1 :b 1)) ; true

    (get {:a 1 :b 1} :a) ; 1

    ({:a 1 :b 1} :a) ; 1

    (:a {:a 1 :b 1}) ; 1

    (contains? {:a 1 :b 1} :a) ; true

    (map? {:a 1 :b 1}) ; true

---


# Sets

    (= #{1 2 3} (hash-set 1 2 3)) ; true

    (get #{1 2 3} 1) ; 1

    (contains? #{1 2 3} 1) ; true
    
    (set? #{1 2 3}) ; true

---

# Seq-grensesnittet, motivasjon

Vi har et antall objekter med en eller annen verdi som skal økes:

    .java
    // eks: [0 1 2 3] blir til [0 2 4 6]
    void double(int[] someArray) {
      int[] newArray = new int[someArray.length];
      for (int i = 0; i < someArray.length; i++){
        newArray[i] = someArray[i] * 2;
      }
      return newArray;
    }


Det vi gjør er at for en gitt samling med data (enten det er tall, strings eller objekter) så
må vi finne ut hvordan vi får tilgang til elementene i samlingen. Dette gjøres som regel ved å:
   
1. Finn ut hvordan man får tilgang til et enkelt element i samlingen
2. Bruk dette i en for-loop som inneholder en eller annen operasjon som gjøres for hvert element


---

#Seq-grensesnittet, forts.

En nyttig abstraksjon for å gjøre dette finner vi i map-funksjonen:

    (map (fn[a] (* 2 a)) [0 1 2 3]) ; (0 2 4 6)

Men, dette fungerer ikke bare for vektorer:

    (map (fn[a] (* 2 a)) '(0 1 2 3)) ; (0 2 4 6)

map-funksjonen støtter alle kolleksjoner som implementerer Seq-grensesnittet, noe både vektorer og lister gjør!

---
#Seq-grensesnittet, forts.

Seq er et grensesnitt som gjør at den underliggende implementasjonen kan ses på som en logisk liste. 

Gjør at kan ha få datastrukturer med mange tilhørende operasjoner.

---

# Tilstand

    (defonce server (run-jetty #'main-routes {:port 8080 :join? false}))

---

# JVMen og Clojure (forklar ut fra dette eksempelet kanskje?)

    (import 'javax.swing.JFrame)
    (def frame (JFrame. "Hello Frame"))
    (.setSize frame 200 200)
    (.setVisible frame true)
    
    (import 'javax.swing.JPanel)
    (def panel (JPanel.))
    (.setContentPane frame panel)
    
    (import 'javax.swing.JButton)
    (def button (JButton. "Click me!"))
    (.add panel button)
    
    (.revalidate button)


---

.center.middle
# Done deal.

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
